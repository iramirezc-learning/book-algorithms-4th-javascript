#!/usr/bin/env node
const assert = require('assert')
const lib = require('../js/lib')
const { StopWatch } = lib
const {
  arrays: { newArrayOf },
  Random
} = require('../js/util')

/**
 * Client that runs two sorting algorithms to compare their running times.
 * @see p.256.
 */
class SortCompare {
  /**
   * Runs two sorting algorithms
   * and compares their running time by
   * calculating its ratio.
   *
   * @example <caption>Insertion vs. Selection</caption>
   * {@lang bash}
   * $ ./SortCompare Insertion Selection 1000 100
   * Insertion: 0.1570000000000001
   * Selection: 0.2410000000000002
   *
   * For 1000 random Doubles
   *     Insertion is 1.5 times faster than Selection
   *
   * @example <caption>Shell vs. Insertion</caption>
   * {@lang bash}
   * $ ./SortCompare Shell Insertion 100000 100
   * Shell: 3.3429999999999978
   * Insertion: 13641.588999999998
   *
   * For 100000 random Doubles
   *     Shell is 4080.6 times faster than Insertion
   *
   * @example <caption>Merge vs. Shell</caption>
   * {@lang bash}
   * $ ./SortCompare Merge Shell 100000 100
   * Merge: 3.3739999999999988
   * Shell: 3.1959999999999993
   *
   * For 100000 random Doubles
   *     Merge is 0.9 times faster than Shell
   *
   * @example <caption>MergeBU vs. Merge</caption>
   * {@lang bash}
   * $ ./SortCompare MergeBU Merge 100000 100
   * MergeBU: 2.6949999999999976
   * Merge: 3.800999999999998
   *
   * For 100000 random Doubles
   *     MergeBU is 1.4 times faster than Merge
   *
   * @example <caption>Quick vs. MergeBU</caption>
   * {@lang bash}
   * $ ./SortCompare Quick MergeBU 100000 100
   * Quick: 2.0709999999999984
   * MergeBU: 2.7499999999999973
   *
   * For 100000 random Doubles
   *     Quick is 1.3 times faster than MergeBU
   *
   * @example <caption>Quick3way vs. Quick</caption>
   * {@lang bash}
   * $ ./SortCompare Quick3way Quick 100000 100
   * # NOTE: for this example I changed `timeRandomInput` implementation
   * # to create duplicated keys by doing `StdRandom.uniform(10)`
   *
   * Quick3way: 0.5800000000000004
   * Quick: 1.1609999999999998
   *
   * For 100000 random Doubles
   *     Quick3way is 2.0 times faster than Quick
   *
   * @example <caption>Heap vs. Quick</caption>
   * {@lang bash}
   * $ ./SortCompare Heap Quick 100000 100
   *
   * Heap: 6.8640000000000025
   * Quick: 2.0819999999999985
   *
   * For 100000 random Doubles
   *     Heap is 0.3 times faster than Quick
   *
   * @param {string} alg1 Name of the first sorting algorithm.
   * @param {string} alg2 Name of the second sorting algorithm.
   * @param {number} n Length for the generated random arrays as input.
   * @param {number} trials Number of trials.
   */
  static run(alg1, alg2, n, trials) {
    const time1 = this.timeRandomInput(alg1, n, trials)
    const time2 = this.timeRandomInput(alg2, n, trials)

    console.log(`${alg1}: ${time1}\n${alg2}: ${time2}\n`)

    const ratio = time2 / time1

    console.log(
      `For ${n} random Doubles\n\
      ${alg1} is ${ratio.toFixed(1)} times faster than ${alg2}\n`
    )
  }

  /**
   * Counts the total running time of a
   * sorting algorithm when is sorting the array `a`.
   * @param {string} algorithmName Name of the sorting algorithm.
   * @param {Array<number>} a The array to be sorted by the sorting algorithm.
   * @returns {number} The total running time.
   * @throws {TypeError} Throws if the algorithm is not implemented.
   */
  static time(algorithmName, a) {
    const sortName = `${algorithmName}Sort`

    if (!lib[sortName]) {
      throw new TypeError(`${sortName} is not defined`)
    }

    const Algorithm = lib[sortName]
    const timer = new StopWatch()

    Algorithm.sort(a)

    const elapsedTime = timer.elapsedTime()

    assert(Algorithm.isSorted(a), 'array is not sorted')

    return elapsedTime
  }

  /**
   * Sums the total time that a sorting algorithm
   * takes to sort a random array of length `n` in a number of `trials`.
   * @param {string} algorithmName Name of the sorting algorithm.
   * @param {number} n The size for the random array.
   * @param {number} trials The number of trials.
   * @returns {number} The total running time of all `trials`.
   */
  static timeRandomInput(algorithmName, n, trials) {
    let total = 0
    let a = []

    for (let t = 0; t < trials; t++) {
      // @ts-ignore
      a = newArrayOf(n, () => Random.uniform())
      total += this.time(algorithmName, a)
    }

    return total
  }

  /**
   * Main execution.
   * @param {Array<string>} args Arguments form the command line.
   */
  static main(args) {
    const alg1 = args[0]
    const alg2 = args[1]
    const n = parseInt(args[2], 10)
    const trials = parseInt(args[3], 10)

    this.run(alg1, alg2, n, trials)
  }
}

SortCompare.main(process.argv.slice(2))
